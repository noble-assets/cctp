//
// Copyright (c) 2023, Â© Circle Internet Financial, LTD.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: circle/cctp/v1/query.proto

package cctpv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Query_Roles_FullMethodName                             = "/circle.cctp.v1.Query/Roles"
	Query_Attester_FullMethodName                          = "/circle.cctp.v1.Query/Attester"
	Query_Attesters_FullMethodName                         = "/circle.cctp.v1.Query/Attesters"
	Query_PerMessageBurnLimit_FullMethodName               = "/circle.cctp.v1.Query/PerMessageBurnLimit"
	Query_PerMessageBurnLimits_FullMethodName              = "/circle.cctp.v1.Query/PerMessageBurnLimits"
	Query_BurningAndMintingPaused_FullMethodName           = "/circle.cctp.v1.Query/BurningAndMintingPaused"
	Query_SendingAndReceivingMessagesPaused_FullMethodName = "/circle.cctp.v1.Query/SendingAndReceivingMessagesPaused"
	Query_MaxMessageBodySize_FullMethodName                = "/circle.cctp.v1.Query/MaxMessageBodySize"
	Query_NextAvailableNonce_FullMethodName                = "/circle.cctp.v1.Query/NextAvailableNonce"
	Query_SignatureThreshold_FullMethodName                = "/circle.cctp.v1.Query/SignatureThreshold"
	Query_TokenPair_FullMethodName                         = "/circle.cctp.v1.Query/TokenPair"
	Query_TokenPairs_FullMethodName                        = "/circle.cctp.v1.Query/TokenPairs"
	Query_UsedNonce_FullMethodName                         = "/circle.cctp.v1.Query/UsedNonce"
	Query_UsedNonces_FullMethodName                        = "/circle.cctp.v1.Query/UsedNonces"
	Query_RemoteTokenMessenger_FullMethodName              = "/circle.cctp.v1.Query/RemoteTokenMessenger"
	Query_RemoteTokenMessengers_FullMethodName             = "/circle.cctp.v1.Query/RemoteTokenMessengers"
	Query_BurnMessageVersion_FullMethodName                = "/circle.cctp.v1.Query/BurnMessageVersion"
	Query_LocalMessageVersion_FullMethodName               = "/circle.cctp.v1.Query/LocalMessageVersion"
	Query_LocalDomain_FullMethodName                       = "/circle.cctp.v1.Query/LocalDomain"
)

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueryClient interface {
	Roles(ctx context.Context, in *QueryRolesRequest, opts ...grpc.CallOption) (*QueryRolesResponse, error)
	// Queries an Attester by index
	Attester(ctx context.Context, in *QueryGetAttesterRequest, opts ...grpc.CallOption) (*QueryGetAttesterResponse, error)
	// Queries a list of Attesters
	Attesters(ctx context.Context, in *QueryAllAttestersRequest, opts ...grpc.CallOption) (*QueryAllAttestersResponse, error)
	// Queries a PerMessageBurnLimit by index
	PerMessageBurnLimit(ctx context.Context, in *QueryGetPerMessageBurnLimitRequest, opts ...grpc.CallOption) (*QueryGetPerMessageBurnLimitResponse, error)
	// Queries a list of PerMessageBurnLimits
	PerMessageBurnLimits(ctx context.Context, in *QueryAllPerMessageBurnLimitsRequest, opts ...grpc.CallOption) (*QueryAllPerMessageBurnLimitsResponse, error)
	// Queries BurningAndMintingPaused
	BurningAndMintingPaused(ctx context.Context, in *QueryGetBurningAndMintingPausedRequest, opts ...grpc.CallOption) (*QueryGetBurningAndMintingPausedResponse, error)
	// Queries SendingAndReceivingPaused
	SendingAndReceivingMessagesPaused(ctx context.Context, in *QueryGetSendingAndReceivingMessagesPausedRequest, opts ...grpc.CallOption) (*QueryGetSendingAndReceivingMessagesPausedResponse, error)
	// Queries the MaxMessageBodySize
	MaxMessageBodySize(ctx context.Context, in *QueryGetMaxMessageBodySizeRequest, opts ...grpc.CallOption) (*QueryGetMaxMessageBodySizeResponse, error)
	// Queries the NextAvailableNonce
	NextAvailableNonce(ctx context.Context, in *QueryGetNextAvailableNonceRequest, opts ...grpc.CallOption) (*QueryGetNextAvailableNonceResponse, error)
	// Queries the SignatureThreshold
	SignatureThreshold(ctx context.Context, in *QueryGetSignatureThresholdRequest, opts ...grpc.CallOption) (*QueryGetSignatureThresholdResponse, error)
	// Queries a TokenPair by index
	TokenPair(ctx context.Context, in *QueryGetTokenPairRequest, opts ...grpc.CallOption) (*QueryGetTokenPairResponse, error)
	// Queries a list of TokenPair
	TokenPairs(ctx context.Context, in *QueryAllTokenPairsRequest, opts ...grpc.CallOption) (*QueryAllTokenPairsResponse, error)
	// Queries a UsedNonce by index
	UsedNonce(ctx context.Context, in *QueryGetUsedNonceRequest, opts ...grpc.CallOption) (*QueryGetUsedNonceResponse, error)
	// Queries a list of UsedNonces
	UsedNonces(ctx context.Context, in *QueryAllUsedNoncesRequest, opts ...grpc.CallOption) (*QueryAllUsedNoncesResponse, error)
	// Query the RemoteTokenMessenger of a specific domain.
	RemoteTokenMessenger(ctx context.Context, in *QueryRemoteTokenMessengerRequest, opts ...grpc.CallOption) (*QueryRemoteTokenMessengerResponse, error)
	// Query all RemoteTokenMessenger's.
	RemoteTokenMessengers(ctx context.Context, in *QueryRemoteTokenMessengersRequest, opts ...grpc.CallOption) (*QueryRemoteTokenMessengersResponse, error)
	BurnMessageVersion(ctx context.Context, in *QueryBurnMessageVersionRequest, opts ...grpc.CallOption) (*QueryBurnMessageVersionResponse, error)
	LocalMessageVersion(ctx context.Context, in *QueryLocalMessageVersionRequest, opts ...grpc.CallOption) (*QueryLocalMessageVersionResponse, error)
	LocalDomain(ctx context.Context, in *QueryLocalDomainRequest, opts ...grpc.CallOption) (*QueryLocalDomainResponse, error)
}

type queryClient struct {
	cc grpc.ClientConnInterface
}

func NewQueryClient(cc grpc.ClientConnInterface) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Roles(ctx context.Context, in *QueryRolesRequest, opts ...grpc.CallOption) (*QueryRolesResponse, error) {
	out := new(QueryRolesResponse)
	err := c.cc.Invoke(ctx, Query_Roles_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Attester(ctx context.Context, in *QueryGetAttesterRequest, opts ...grpc.CallOption) (*QueryGetAttesterResponse, error) {
	out := new(QueryGetAttesterResponse)
	err := c.cc.Invoke(ctx, Query_Attester_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Attesters(ctx context.Context, in *QueryAllAttestersRequest, opts ...grpc.CallOption) (*QueryAllAttestersResponse, error) {
	out := new(QueryAllAttestersResponse)
	err := c.cc.Invoke(ctx, Query_Attesters_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) PerMessageBurnLimit(ctx context.Context, in *QueryGetPerMessageBurnLimitRequest, opts ...grpc.CallOption) (*QueryGetPerMessageBurnLimitResponse, error) {
	out := new(QueryGetPerMessageBurnLimitResponse)
	err := c.cc.Invoke(ctx, Query_PerMessageBurnLimit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) PerMessageBurnLimits(ctx context.Context, in *QueryAllPerMessageBurnLimitsRequest, opts ...grpc.CallOption) (*QueryAllPerMessageBurnLimitsResponse, error) {
	out := new(QueryAllPerMessageBurnLimitsResponse)
	err := c.cc.Invoke(ctx, Query_PerMessageBurnLimits_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) BurningAndMintingPaused(ctx context.Context, in *QueryGetBurningAndMintingPausedRequest, opts ...grpc.CallOption) (*QueryGetBurningAndMintingPausedResponse, error) {
	out := new(QueryGetBurningAndMintingPausedResponse)
	err := c.cc.Invoke(ctx, Query_BurningAndMintingPaused_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) SendingAndReceivingMessagesPaused(ctx context.Context, in *QueryGetSendingAndReceivingMessagesPausedRequest, opts ...grpc.CallOption) (*QueryGetSendingAndReceivingMessagesPausedResponse, error) {
	out := new(QueryGetSendingAndReceivingMessagesPausedResponse)
	err := c.cc.Invoke(ctx, Query_SendingAndReceivingMessagesPaused_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) MaxMessageBodySize(ctx context.Context, in *QueryGetMaxMessageBodySizeRequest, opts ...grpc.CallOption) (*QueryGetMaxMessageBodySizeResponse, error) {
	out := new(QueryGetMaxMessageBodySizeResponse)
	err := c.cc.Invoke(ctx, Query_MaxMessageBodySize_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) NextAvailableNonce(ctx context.Context, in *QueryGetNextAvailableNonceRequest, opts ...grpc.CallOption) (*QueryGetNextAvailableNonceResponse, error) {
	out := new(QueryGetNextAvailableNonceResponse)
	err := c.cc.Invoke(ctx, Query_NextAvailableNonce_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) SignatureThreshold(ctx context.Context, in *QueryGetSignatureThresholdRequest, opts ...grpc.CallOption) (*QueryGetSignatureThresholdResponse, error) {
	out := new(QueryGetSignatureThresholdResponse)
	err := c.cc.Invoke(ctx, Query_SignatureThreshold_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) TokenPair(ctx context.Context, in *QueryGetTokenPairRequest, opts ...grpc.CallOption) (*QueryGetTokenPairResponse, error) {
	out := new(QueryGetTokenPairResponse)
	err := c.cc.Invoke(ctx, Query_TokenPair_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) TokenPairs(ctx context.Context, in *QueryAllTokenPairsRequest, opts ...grpc.CallOption) (*QueryAllTokenPairsResponse, error) {
	out := new(QueryAllTokenPairsResponse)
	err := c.cc.Invoke(ctx, Query_TokenPairs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) UsedNonce(ctx context.Context, in *QueryGetUsedNonceRequest, opts ...grpc.CallOption) (*QueryGetUsedNonceResponse, error) {
	out := new(QueryGetUsedNonceResponse)
	err := c.cc.Invoke(ctx, Query_UsedNonce_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) UsedNonces(ctx context.Context, in *QueryAllUsedNoncesRequest, opts ...grpc.CallOption) (*QueryAllUsedNoncesResponse, error) {
	out := new(QueryAllUsedNoncesResponse)
	err := c.cc.Invoke(ctx, Query_UsedNonces_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) RemoteTokenMessenger(ctx context.Context, in *QueryRemoteTokenMessengerRequest, opts ...grpc.CallOption) (*QueryRemoteTokenMessengerResponse, error) {
	out := new(QueryRemoteTokenMessengerResponse)
	err := c.cc.Invoke(ctx, Query_RemoteTokenMessenger_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) RemoteTokenMessengers(ctx context.Context, in *QueryRemoteTokenMessengersRequest, opts ...grpc.CallOption) (*QueryRemoteTokenMessengersResponse, error) {
	out := new(QueryRemoteTokenMessengersResponse)
	err := c.cc.Invoke(ctx, Query_RemoteTokenMessengers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) BurnMessageVersion(ctx context.Context, in *QueryBurnMessageVersionRequest, opts ...grpc.CallOption) (*QueryBurnMessageVersionResponse, error) {
	out := new(QueryBurnMessageVersionResponse)
	err := c.cc.Invoke(ctx, Query_BurnMessageVersion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) LocalMessageVersion(ctx context.Context, in *QueryLocalMessageVersionRequest, opts ...grpc.CallOption) (*QueryLocalMessageVersionResponse, error) {
	out := new(QueryLocalMessageVersionResponse)
	err := c.cc.Invoke(ctx, Query_LocalMessageVersion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) LocalDomain(ctx context.Context, in *QueryLocalDomainRequest, opts ...grpc.CallOption) (*QueryLocalDomainResponse, error) {
	out := new(QueryLocalDomainResponse)
	err := c.cc.Invoke(ctx, Query_LocalDomain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
// All implementations must embed UnimplementedQueryServer
// for forward compatibility
type QueryServer interface {
	Roles(context.Context, *QueryRolesRequest) (*QueryRolesResponse, error)
	// Queries an Attester by index
	Attester(context.Context, *QueryGetAttesterRequest) (*QueryGetAttesterResponse, error)
	// Queries a list of Attesters
	Attesters(context.Context, *QueryAllAttestersRequest) (*QueryAllAttestersResponse, error)
	// Queries a PerMessageBurnLimit by index
	PerMessageBurnLimit(context.Context, *QueryGetPerMessageBurnLimitRequest) (*QueryGetPerMessageBurnLimitResponse, error)
	// Queries a list of PerMessageBurnLimits
	PerMessageBurnLimits(context.Context, *QueryAllPerMessageBurnLimitsRequest) (*QueryAllPerMessageBurnLimitsResponse, error)
	// Queries BurningAndMintingPaused
	BurningAndMintingPaused(context.Context, *QueryGetBurningAndMintingPausedRequest) (*QueryGetBurningAndMintingPausedResponse, error)
	// Queries SendingAndReceivingPaused
	SendingAndReceivingMessagesPaused(context.Context, *QueryGetSendingAndReceivingMessagesPausedRequest) (*QueryGetSendingAndReceivingMessagesPausedResponse, error)
	// Queries the MaxMessageBodySize
	MaxMessageBodySize(context.Context, *QueryGetMaxMessageBodySizeRequest) (*QueryGetMaxMessageBodySizeResponse, error)
	// Queries the NextAvailableNonce
	NextAvailableNonce(context.Context, *QueryGetNextAvailableNonceRequest) (*QueryGetNextAvailableNonceResponse, error)
	// Queries the SignatureThreshold
	SignatureThreshold(context.Context, *QueryGetSignatureThresholdRequest) (*QueryGetSignatureThresholdResponse, error)
	// Queries a TokenPair by index
	TokenPair(context.Context, *QueryGetTokenPairRequest) (*QueryGetTokenPairResponse, error)
	// Queries a list of TokenPair
	TokenPairs(context.Context, *QueryAllTokenPairsRequest) (*QueryAllTokenPairsResponse, error)
	// Queries a UsedNonce by index
	UsedNonce(context.Context, *QueryGetUsedNonceRequest) (*QueryGetUsedNonceResponse, error)
	// Queries a list of UsedNonces
	UsedNonces(context.Context, *QueryAllUsedNoncesRequest) (*QueryAllUsedNoncesResponse, error)
	// Query the RemoteTokenMessenger of a specific domain.
	RemoteTokenMessenger(context.Context, *QueryRemoteTokenMessengerRequest) (*QueryRemoteTokenMessengerResponse, error)
	// Query all RemoteTokenMessenger's.
	RemoteTokenMessengers(context.Context, *QueryRemoteTokenMessengersRequest) (*QueryRemoteTokenMessengersResponse, error)
	BurnMessageVersion(context.Context, *QueryBurnMessageVersionRequest) (*QueryBurnMessageVersionResponse, error)
	LocalMessageVersion(context.Context, *QueryLocalMessageVersionRequest) (*QueryLocalMessageVersionResponse, error)
	LocalDomain(context.Context, *QueryLocalDomainRequest) (*QueryLocalDomainResponse, error)
	mustEmbedUnimplementedQueryServer()
}

// UnimplementedQueryServer must be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (UnimplementedQueryServer) Roles(context.Context, *QueryRolesRequest) (*QueryRolesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Roles not implemented")
}
func (UnimplementedQueryServer) Attester(context.Context, *QueryGetAttesterRequest) (*QueryGetAttesterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attester not implemented")
}
func (UnimplementedQueryServer) Attesters(context.Context, *QueryAllAttestersRequest) (*QueryAllAttestersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attesters not implemented")
}
func (UnimplementedQueryServer) PerMessageBurnLimit(context.Context, *QueryGetPerMessageBurnLimitRequest) (*QueryGetPerMessageBurnLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PerMessageBurnLimit not implemented")
}
func (UnimplementedQueryServer) PerMessageBurnLimits(context.Context, *QueryAllPerMessageBurnLimitsRequest) (*QueryAllPerMessageBurnLimitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PerMessageBurnLimits not implemented")
}
func (UnimplementedQueryServer) BurningAndMintingPaused(context.Context, *QueryGetBurningAndMintingPausedRequest) (*QueryGetBurningAndMintingPausedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurningAndMintingPaused not implemented")
}
func (UnimplementedQueryServer) SendingAndReceivingMessagesPaused(context.Context, *QueryGetSendingAndReceivingMessagesPausedRequest) (*QueryGetSendingAndReceivingMessagesPausedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendingAndReceivingMessagesPaused not implemented")
}
func (UnimplementedQueryServer) MaxMessageBodySize(context.Context, *QueryGetMaxMessageBodySizeRequest) (*QueryGetMaxMessageBodySizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MaxMessageBodySize not implemented")
}
func (UnimplementedQueryServer) NextAvailableNonce(context.Context, *QueryGetNextAvailableNonceRequest) (*QueryGetNextAvailableNonceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NextAvailableNonce not implemented")
}
func (UnimplementedQueryServer) SignatureThreshold(context.Context, *QueryGetSignatureThresholdRequest) (*QueryGetSignatureThresholdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignatureThreshold not implemented")
}
func (UnimplementedQueryServer) TokenPair(context.Context, *QueryGetTokenPairRequest) (*QueryGetTokenPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenPair not implemented")
}
func (UnimplementedQueryServer) TokenPairs(context.Context, *QueryAllTokenPairsRequest) (*QueryAllTokenPairsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenPairs not implemented")
}
func (UnimplementedQueryServer) UsedNonce(context.Context, *QueryGetUsedNonceRequest) (*QueryGetUsedNonceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UsedNonce not implemented")
}
func (UnimplementedQueryServer) UsedNonces(context.Context, *QueryAllUsedNoncesRequest) (*QueryAllUsedNoncesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UsedNonces not implemented")
}
func (UnimplementedQueryServer) RemoteTokenMessenger(context.Context, *QueryRemoteTokenMessengerRequest) (*QueryRemoteTokenMessengerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoteTokenMessenger not implemented")
}
func (UnimplementedQueryServer) RemoteTokenMessengers(context.Context, *QueryRemoteTokenMessengersRequest) (*QueryRemoteTokenMessengersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoteTokenMessengers not implemented")
}
func (UnimplementedQueryServer) BurnMessageVersion(context.Context, *QueryBurnMessageVersionRequest) (*QueryBurnMessageVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnMessageVersion not implemented")
}
func (UnimplementedQueryServer) LocalMessageVersion(context.Context, *QueryLocalMessageVersionRequest) (*QueryLocalMessageVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LocalMessageVersion not implemented")
}
func (UnimplementedQueryServer) LocalDomain(context.Context, *QueryLocalDomainRequest) (*QueryLocalDomainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LocalDomain not implemented")
}
func (UnimplementedQueryServer) mustEmbedUnimplementedQueryServer() {}

// UnsafeQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueryServer will
// result in compilation errors.
type UnsafeQueryServer interface {
	mustEmbedUnimplementedQueryServer()
}

func RegisterQueryServer(s grpc.ServiceRegistrar, srv QueryServer) {
	s.RegisterService(&Query_ServiceDesc, srv)
}

func _Query_Roles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRolesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Roles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Roles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Roles(ctx, req.(*QueryRolesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Attester_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGetAttesterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Attester(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Attester_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Attester(ctx, req.(*QueryGetAttesterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Attesters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllAttestersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Attesters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Attesters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Attesters(ctx, req.(*QueryAllAttestersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_PerMessageBurnLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGetPerMessageBurnLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).PerMessageBurnLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_PerMessageBurnLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).PerMessageBurnLimit(ctx, req.(*QueryGetPerMessageBurnLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_PerMessageBurnLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllPerMessageBurnLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).PerMessageBurnLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_PerMessageBurnLimits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).PerMessageBurnLimits(ctx, req.(*QueryAllPerMessageBurnLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_BurningAndMintingPaused_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGetBurningAndMintingPausedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).BurningAndMintingPaused(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_BurningAndMintingPaused_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).BurningAndMintingPaused(ctx, req.(*QueryGetBurningAndMintingPausedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_SendingAndReceivingMessagesPaused_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGetSendingAndReceivingMessagesPausedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).SendingAndReceivingMessagesPaused(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_SendingAndReceivingMessagesPaused_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).SendingAndReceivingMessagesPaused(ctx, req.(*QueryGetSendingAndReceivingMessagesPausedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_MaxMessageBodySize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGetMaxMessageBodySizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).MaxMessageBodySize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_MaxMessageBodySize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).MaxMessageBodySize(ctx, req.(*QueryGetMaxMessageBodySizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_NextAvailableNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGetNextAvailableNonceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).NextAvailableNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_NextAvailableNonce_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).NextAvailableNonce(ctx, req.(*QueryGetNextAvailableNonceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_SignatureThreshold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGetSignatureThresholdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).SignatureThreshold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_SignatureThreshold_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).SignatureThreshold(ctx, req.(*QueryGetSignatureThresholdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_TokenPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGetTokenPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TokenPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_TokenPair_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TokenPair(ctx, req.(*QueryGetTokenPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_TokenPairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllTokenPairsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TokenPairs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_TokenPairs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TokenPairs(ctx, req.(*QueryAllTokenPairsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_UsedNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGetUsedNonceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).UsedNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_UsedNonce_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).UsedNonce(ctx, req.(*QueryGetUsedNonceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_UsedNonces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllUsedNoncesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).UsedNonces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_UsedNonces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).UsedNonces(ctx, req.(*QueryAllUsedNoncesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_RemoteTokenMessenger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRemoteTokenMessengerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).RemoteTokenMessenger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_RemoteTokenMessenger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).RemoteTokenMessenger(ctx, req.(*QueryRemoteTokenMessengerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_RemoteTokenMessengers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRemoteTokenMessengersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).RemoteTokenMessengers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_RemoteTokenMessengers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).RemoteTokenMessengers(ctx, req.(*QueryRemoteTokenMessengersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_BurnMessageVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBurnMessageVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).BurnMessageVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_BurnMessageVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).BurnMessageVersion(ctx, req.(*QueryBurnMessageVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_LocalMessageVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryLocalMessageVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).LocalMessageVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_LocalMessageVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).LocalMessageVersion(ctx, req.(*QueryLocalMessageVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_LocalDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryLocalDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).LocalDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_LocalDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).LocalDomain(ctx, req.(*QueryLocalDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Query_ServiceDesc is the grpc.ServiceDesc for Query service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Query_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "circle.cctp.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Roles",
			Handler:    _Query_Roles_Handler,
		},
		{
			MethodName: "Attester",
			Handler:    _Query_Attester_Handler,
		},
		{
			MethodName: "Attesters",
			Handler:    _Query_Attesters_Handler,
		},
		{
			MethodName: "PerMessageBurnLimit",
			Handler:    _Query_PerMessageBurnLimit_Handler,
		},
		{
			MethodName: "PerMessageBurnLimits",
			Handler:    _Query_PerMessageBurnLimits_Handler,
		},
		{
			MethodName: "BurningAndMintingPaused",
			Handler:    _Query_BurningAndMintingPaused_Handler,
		},
		{
			MethodName: "SendingAndReceivingMessagesPaused",
			Handler:    _Query_SendingAndReceivingMessagesPaused_Handler,
		},
		{
			MethodName: "MaxMessageBodySize",
			Handler:    _Query_MaxMessageBodySize_Handler,
		},
		{
			MethodName: "NextAvailableNonce",
			Handler:    _Query_NextAvailableNonce_Handler,
		},
		{
			MethodName: "SignatureThreshold",
			Handler:    _Query_SignatureThreshold_Handler,
		},
		{
			MethodName: "TokenPair",
			Handler:    _Query_TokenPair_Handler,
		},
		{
			MethodName: "TokenPairs",
			Handler:    _Query_TokenPairs_Handler,
		},
		{
			MethodName: "UsedNonce",
			Handler:    _Query_UsedNonce_Handler,
		},
		{
			MethodName: "UsedNonces",
			Handler:    _Query_UsedNonces_Handler,
		},
		{
			MethodName: "RemoteTokenMessenger",
			Handler:    _Query_RemoteTokenMessenger_Handler,
		},
		{
			MethodName: "RemoteTokenMessengers",
			Handler:    _Query_RemoteTokenMessengers_Handler,
		},
		{
			MethodName: "BurnMessageVersion",
			Handler:    _Query_BurnMessageVersion_Handler,
		},
		{
			MethodName: "LocalMessageVersion",
			Handler:    _Query_LocalMessageVersion_Handler,
		},
		{
			MethodName: "LocalDomain",
			Handler:    _Query_LocalDomain_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "circle/cctp/v1/query.proto",
}
